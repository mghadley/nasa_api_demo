"use strict";

var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

/* @flow */

var Promise = require("bluebird");
var JSONStream = require("json-stream");
var EventEmitter = require("events").EventEmitter;

var RETRIES = 7;
var DELAY = 500;

/*:: type stdout = (output: string) => any*/
/*:: type msg = {data: ?string; error: ?string; command: string; }*/

var ReplitClient = (function (EventEmitter) {
  /*:: _host: string; */
  /*:: _port: string; */
  /*:: _language: string; */
  /*:: _authToken: string; */
  /*:: _authFailed: boolean; */
  /*:: _retries: number; */
  /*:: _jsonStream: any; */
  /*:: _ws: any; */
  /*:: _stdout: ?stdout; */
  /*:: _msgQueue: Array<msg>; */
  /*:: _msgResolvers: Array<function>; */
  /*:: _connecting: ?Promise; */
  /*:: _evalConnecting: ?Promise; */
  /*:: _pingTimer: number; */
  /*:: _socketCreator: ?function; */

  function ReplitClient(host, /*: string*/port, /*: string*/language, /*: string*/authToken, /*: { msg_mac: string; time_created: number; }*/socketCreator /*: function*/
  ) {
    _get(Object.getPrototypeOf(ReplitClient.prototype), "constructor", this).call(this);
    this._host = host;
    this._port = port;
    this._language = language;
    this._authToken = authToken.time_created + ":" + authToken.msg_mac;
    this._init();
    this._retries = RETRIES;
    this._socketCreator = socketCreator;
  }

  _inherits(ReplitClient, EventEmitter);

  _prototypeProperties(ReplitClient, null, {
    connect: {
      value: function connect() /*: Promise<ReplitClient>*/{
        if (this._connecting) {
          return this._connecting;
        }

        this._connecting = this._connect();
        return this._connecting;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    disconnect: {
      value: function disconnect() /*: Promise<bool>*/{
        var _this = this;
        if (!(this._ws && this._ws.readyState === this._ws.OPEN)) {
          return Promise.resolve(true);
        }

        clearTimeout(this._pingTimer);
        return new Promise(function (resolve) {
          _this._ws.onclose = function () {
            return resolve(true);
          };
          _this._ws.close();
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    write: {
      value: function write(str /*: string*/) {
        var _this2 = this;
        if (!this._evalConnecting) {
          return Promise.reject(new Error("Must evaluate before writing"));
        }
        return this._evalConnecting.then(function () {
          _this2._sendMessage("input", str);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    evaluate: {
      value: function evaluate(code, /*: string*/_ref) /*: Promise<{
                                                        error: ?string;
                                                        data: ?string;
                                                        }>*/
      {
        var _this3 = this;
        var stdout = _ref.stdout;
        this._evalConnecting = this._connectOrTry();
        return this._evalConnecting.then(function () {
          _this3._stdout = stdout;
          _this3._sendMessage("eval", code);
          return _this3._waitForResult();
        }).then(function (result) {
          _this3._evalConnecting = null;
          return result;
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    evaluateOnce: {
      value: function evaluateOnce(code, /*: string*/options /*: ?{
                                                             stdout: ?stdout,
                                                             timeout: ?{
                                                             time: number,
                                                             callback: () => bool
                                                             }
                                                             }*/
      ) /*: Promise<{
         error: ?string;
         data: ?string;
         }>*/
      {
        var _this4 = this;
        return new Promise(function (resolve, reject) {
          var req = new XMLHttpRequest();

          var t = null;
          if (options != null && options.timeout) {
            var callback;
            (function () {
              var timeout = options.timeout;
              callback = function () {
                // this is just to make flow happy
                var stop = timeout.callback();
                if (stop) {
                  req.abort();
                  reject(new Error("Aborted"));
                } else {
                  t = setTimeout(callback, timeout.time);
                }
              };

              t = setTimeout(callback, timeout.time);
            })();
          }

          req.onload = function () {
            if (req.status !== 200) {
              clearTimeout(t);
              reject(new Error(req.responseText));
            } else {
              var data /*: Array<msg>*/ = [];
              try {
                data = JSON.parse(req.responseText);
              } catch (e) {
                clearTimeout(t);
                reject(new Error("Error parsing response"));
                return;
              }
              data.forEach(function (msg) {
                if (msg.command === "output") {
                  if (options && options.stdout != null) {
                    options.stdout(msg.data);
                  }
                } else if (msg.command === "result") {
                  clearTimeout(t);
                  resolve(msg);
                }
              });
            }
          };

          var protocol = "http";
          var port = _this4._port;
          if (typeof location === "object" && location.protocol === "https:") {
            protocol = "https";
            if (port === 80 || port === "80") {
              port = 443;
            }
          }

          req.open("POST", protocol + "://" + _this4._host + ":" + port + "/eval", true);

          req.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; param=value");

          var data = "";
          data += "auth=" + encodeURIComponent(_this4._authToken);
          data += "&language=" + encodeURIComponent(_this4._language);
          data += "&code=" + encodeURIComponent(code);

          req.send(data);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _waitUntilReady: {
      value: function WaitUntilReady() {
        var _this5 = this;
        return this._nextMessage().then(function (msg) {
          if (msg.command === "ready") {
            return msg;
          }

          return _this5._waitUntilReady();
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    stop: {
      value: function stop() /*: Promise*/{
        return this._reset("stop");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    reset: {
      value: function reset() /*: Promise*/{
        return this._reset("reset");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _reset: {
      value: function Reset(message) /*: Promise*/{
        var _this6 = this;
        return this._connectOrTry().then(function () {
          var resolver;
          while (resolver = _this6._msgResolvers.shift()) {
            resolver({ command: "skip" });
          }
          _this6._sendMessage(message);
          return _this6._waitUntilReady();
        }).then(function (msg) {
          if (msg.command !== "ready") {
            throw new Error("Expected ready after reset");
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    runProject: {
      value: function runProject(files, /*: Array<file>*/_ref2) /*: Promise<{
                                                                   error: ?string;
                                                                   data: ?string;
                                                                   }>*/
      {
        var _this7 = this;
        var stdout = _ref2.stdout;
        this._evalConnecting = this.reset();
        return this._evalConnecting.then(function () {
          _this7._stdout = stdout;
          // Need to stringify files because 'data' field is expected
          // to be string and not array.
          _this7._sendMessage("runProject", JSON.stringify(files));
          return _this7._waitForResult();
        }).then(function (result) {
          _this7._evalConnecting = null;
          return result;
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _init: {
      value: function Init() {
        var _this8 = this;
        // Cleanup if we're retrying a closed connection.
        if (this._jsonStream) {
          this._jsonStream.removeAllListeners();
          this._jsonStream = null;
        }

        this._ws = null;
        this._stdout = null;

        this._msgQueue = [];
        this._msgResolvers = [];

        this._jsonStream = JSONStream();
        this._jsonStream.on("data", function (msg) {
          if (msg.command === "pong") {
            _this8._ping();
            return;
          } else if (msg.command === "ping") {
            _this8._pong();
            return;
          }

          if (_this8._msgResolvers.length) {
            var resolver = _this8._msgResolvers.shift();
            resolver(msg);
          } else {
            _this8._msgQueue.push(msg);
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _nextMessage: {
      value: function NextMessage() /*: Promise*/{
        var _this9 = this;
        return new Promise(function (resolve) {
          if (_this9._msgQueue.length) {
            resolve(_this9._msgQueue.shift());
          } else {
            _this9._msgResolvers.push(resolve);
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _connectOrTry: {

      // This will make sure we at least try to connect
      // and not get stuck in some past error.
      // use case is what if we were disconnected from the internet
      // and now we are connected.
      value: function ConnectOrTry() /*: Promise<ReplitClient> */{
        var _this10 = this;
        return this.connect()["catch"](function () {
          _this10._connecting = null;
          return _this10.connect();
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _connect: {
      value: function Connect() /*: Promise<ReplitClient>*/{
        var _this11 = this;
        return new Promise(function (resolve, reject) {
          _this11.emit("connecting");

          var protocol = "ws";
          var port = _this11._port;
          if (typeof location === "object" && location.protocol === "https:") {
            protocol = "wss";
            if (port === 80 || port === "80") {
              port = 443;
            }
          }

          var url = protocol + "://" + _this11._host + ":" + port + "/ws";
          _this11._ws = _this11._socketCreator ? _this11._socketCreator(url) : new WebSocket(url);
          _this11._ws.onopen = function () {
            _this11._retries = RETRIES;
            _this11._handshake().then(function () {
              resolve(_this11);
              _this11.emit("connected");
            }, function () {
              return _this11.disconnect().then(reject, reject);
            });
            _this11._ws.onclose = _this11._closeHandler.bind(_this11);
          };
          _this11._ws.onclose = function (e) {
            reject(new Error(errMsgFromCloseEvent(e)));
          }, _this11._ws.onmessage = _this11._messageHandler.bind(_this11);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _handshake: {
      value: function Handshake() /*: Promise */{
        var _this12 = this;
        var msg;

        this._sendMessage("auth", this._authToken);
        return this._nextMessage().then(function (msg) {
          if (msg.command !== "auth_result") {
            throw new Error("Expected \"auth_result\" command: " + msg.command);
          }
          if (msg.data !== "true") {
            _this12._authFailed = true;
            throw new Error("Failed to auth");
          }
          _this12._sendMessage("select_language", _this12._language);
          return _this12._nextMessage();
        }).then(function (msg) {
          if (msg.command !== "ready") {
            _this12._authFailed = true;
            if (msg.command === "error") {
              throw new Error(msg.data);
            }
            throw new Error("Expected \"ready\" command but got: " + msg.command);
          }

          _this12._ping();
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _sendMessage: {
      value: function SendMessage(command /*: string*/) {
        var data /*: string*/ = arguments[1] === undefined ? "" : arguments[1];
        var msg = { command: command, data: data };
        this._ws.send(JSON.stringify(msg));
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _messageHandler: {
      value: function MessageHandler(e /*: {data: string} */) {
        this._jsonStream.write(e.data);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _waitForResult: {
      value: function WaitForResult() /*: Promise*/{
        var _this13 = this;
        return this._nextMessage().then(function (msg) {
          switch (msg.command) {
            case "result":
              return msg;
            case "output":
              if (_this13._stdout != null) {
                _this13._stdout(msg.data);
              }
              return _this13._waitForResult();
            case "input":
              return _this13._waitForResult();
            case "skip":
              return { command: "result", data: "" };
          }
          throw new Error("Unexpected command: " + msg.command);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _closeHandler: {
      value: function CloseHandler(e /*: CloseEvent */) {
        var _this14 = this;
        this._init();
        this._retries -= 1;
        clearTimeout(this._pingTimer);

        if (this._authFailed) {
          this._retries = 0;
        }

        if (this._retries < 1) {
          this.emit("disconnected", { retry: false });
          this._connecting = null;
          this._retries = 0;
          return Promise.reject(e);
        } else {
          var delay = (RETRIES - this._retries) * DELAY;
          this.emit("disconnected", { retry: true, delay: delay });
          this._connecting = new Promise(function (resolve, reject) {
            setTimeout(function () {
              return _this14._connect().then(resolve, reject);
            }, delay);
          });
          return this._connecting["catch"](function (e) {
            return _this14._closeHandler(e);
          });
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _ping: {
      value: function Ping() {
        var _this15 = this;
        this._pingTimer = setTimeout(function () {
          _this15._ws.send(JSON.stringify({ command: "ping" }));
        }, 10 * 1000);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _pong: {
      value: function Pong() {
        this._ws.send(JSON.stringify({ command: "pong" }));
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return ReplitClient;
})(EventEmitter);

function errMsgFromCloseEvent(e) {
  var msg = e.reason || e.type || "";
  if (e.code) {
    msg += ": " + e.code;
  }
  return msg;
}

module.exports = ReplitClient;
/*: { stdout: ?stdout }*/
/*: { stdout: ?stdout }*/

